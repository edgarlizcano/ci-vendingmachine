let logger = {};
let log4js = require('log4js');
let log = log4js.getLogger('log');
let stringformat = require('stringformat');
stringformat.extendString();
let stackTrace = require('stack-trace');
let fs = require('fs');
let _disableLog = false;
let _configOk = false;
let _dir = './logs';
const path = require('path');
let _async = new require('async');
let _queue = null;

_queue = _async.queue(AddLogToFile, 1);

logger.level = {
    "INFO" : { value: 0, text: "INFO" },
    "DEBUG" : { value: 1, text: "DEBUG" },
    "WARNING": { value: 2, text: "WARNING" },
    "ERROR": { value: 3, text: "ERROR"},
    "FATAL" : { value: 4, text: "FATAL" }
};


//********************************************************************
//logger.init
//********************************************************************
logger.init = function(data) {
    try{
        let folderExist = false;

        if (data === undefined || data === null || data.pathFolder === undefined || data.pathFolder === null)
        {
			data = {
				"pathFolder": "",
				"maxLogSizeMB": 100,
				"backups": 5,
				"fileName": "app.log",
				"level": "INFO"
			};
            
        }

        _dir = data.pathFolder;

        if(_dir.length > 0)
        {
            if(FileExist(_dir) === 1)
            {
                try{
                    fs.mkdirSync(_dir);
                    if(FileExist(_dir) === 0)
                    {
                        folderExist=true;
                    }
                }
                catch (err) {
                    //global.log.write("Exception:{0}".format(err.toString()));
                }
            }
            else
            {
                folderExist = true;
            }
        }

        log.setLevel(data.level);

        if(folderExist)
        {
            let pathFile = "{0}.log".format(_dir);

            log4js.configure({
                appenders: [
                    { "type": 'console' },
                    {
                        "type": "file",
                        "filename": path.join(data.pathFolder, data.fileName),
                        "maxLogSize": data.maxLogSizeMB*1024*1024,
                        "backups": data.backups,
                        "category": 'log'
                    }
                ]
            });

        }
        else
        {
            _dir = "";
            log4js.configure({
                appenders: [
                    { type: 'console' }
                ]
            });
        }

        _configOk = true;
    }
    catch (err) {
        console.log("Error exception:".format(err));
    }
}


//********************************************************************
//logger.disabled
//********************************************************************
logger.disabled = function(state) {
    _disableLog = state;
};

//********************************************************************
//logger.write
//********************************************************************
logger.write = function(data, level) {
    try{
        if(_disableLog)
        {
            return;
        }

        let file, frame, line, method;

        frame = stackTrace.get()[1];
        file = path.basename(frame.getFileName());
        line = frame.getLineNumber();
        method = frame.getFunctionName();

        let strData = '{0}:{1}:{2}:{3}'.format(file, method, line, data);

        _queue.push({data: strData, level: level});

    }
    catch (err){
        console.log("Error exception:".format(err));
    }
};

logger.info = function(data) {
    try{
        if(_disableLog)
        {
            return;
        }

        let file, frame, line, method;

        frame = stackTrace.get()[1];
        file = path.basename(frame.getFileName());
        line = frame.getLineNumber();
        method = frame.getFunctionName();

        let strData = '{0}:{1}:{2}:{3}'.format(file, method, line, data);

        _queue.push({data: strData, level: logger.level.INFO});

    }
    catch (err){
        console.log("Error exception:".format(err));
    }
};

logger.error = function(data) {
    try{
        if(_disableLog)
        {
            return;
        }

        let file, frame, line, method;

        frame = stackTrace.get()[1];
        file = path.basename(frame.getFileName());
        line = frame.getLineNumber();
        method = frame.getFunctionName();

        let strData = '{0}:{1}:{2}:{3}'.format(file, method, line, data);

        _queue.push({data: strData, level: logger.level.ERROR});

    }
    catch (err){
        console.log("Error exception:".format(err));
    }
};

logger.warning = function(data) {
    try{
        if(_disableLog)
        {
            return;
        }

        let file, frame, line, method;

        frame = stackTrace.get()[1];
        file = path.basename(frame.getFileName());
        line = frame.getLineNumber();
        method = frame.getFunctionName();

        let strData = '{0}:{1}:{2}:{3}'.format(file, method, line, data);

        _queue.push({data: strData, level: logger.level.WARNING});

    }
    catch (err){
        console.log("Error exception:".format(err));
    }
};

logger.fatal = function(data) {
    try{
        if(_disableLog)
        {
            return;
        }

        let file, frame, line, method;

        frame = stackTrace.get()[1];
        file = path.basename(frame.getFileName());
        line = frame.getLineNumber();
        method = frame.getFunctionName();

        let strData = '{0}:{1}:{2}:{3}'.format(file, method, line, data);

        _queue.push({data: strData, level: logger.level.FATAL});

    }
    catch (err){
        console.log("Error exception:".format(err));
    }
};

logger.debug = function(data) {
    try{
        if(_disableLog)
        {
            return;
        }

        let file, frame, line, method;

        frame = stackTrace.get()[1];
        file = path.basename(frame.getFileName());
        line = frame.getLineNumber();
        method = frame.getFunctionName();

        let strData = '{0}:{1}:{2}:{3}'.format(file, method, line, data);

        _queue.push({data: strData, level: logger.level.DEBUG});

    }
    catch (err){
        console.log("Error exception:".format(err));
    }
};

//********************************************************************
//AddLogToFile
//********************************************************************
function AddLogToFile(data, cb) {
    try{
        if ( typeof data !== 'undefined' && data)
        {
            if (typeof data.level === 'undefined') {
                data.level = logger.level.INFO;
            }

            if(_configOk === false)
            {
                logger.init(null);
            }
            else
            {
                if(_dir.length > 0)
                {
                    if (!fs.existsSync(_dir)){
                        fs.mkdirSync(_dir);
                    }
                }
            }

            switch(data.level){
                case logger.level.INFO:
                    log.info(data.data);
                    break;

                case logger.level.DEBUG:
                    log.debug(data.data);
                    break;

                case logger.level.WARNING:
                    log.warn(data.data);
                    break;

                case logger.level.ERROR:
                    log.error(data.data);
                    break;

                case logger.level.FATAL:
                    log.fatal(data.data);
                    break;
            }

        }
        cb(null);
    }
    catch (err) {
        console.log("Error exception:".format(err));
        cb(err);
    }
}


//********************************************************************
//FileExist
//********************************************************************
function FileExist(pathFile) {
    let returnValue = 1;
    try {
        fs.accessSync(pathFile, fs.F_OK);
        returnValue = 0;
    }
    catch (err) {
        console.log("Error exception:".format(err));
    }
    return returnValue;
}


module.exports = logger;